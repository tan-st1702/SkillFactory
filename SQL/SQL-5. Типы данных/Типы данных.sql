/*markdown
![Alt text](image.png)
*/

/*markdown
#  ОСНОВНЫЕ ТИПЫ ДАННЫХ В POSTGRESQL
*/

/*markdown
Типы данных в *PostgreSQL* можно разделить на несколько групп. К основным относятся:

* числовые типы — для хранения чисел (целых и дробных);
* типы даты/времени — для хранения даты, времени, часовых поясов;
* символьные типы — для хранения символов или строк;
* логический тип — для хранения значений типа «истина», «ложь».
*/

/*markdown
### Даты: основные типы
*/

/*markdown
![Alt text](image-1.png)
*/

/*markdown
### **TIMESTAMP**
*/

/*markdown
![Alt text](image-2.png)
*/

/*markdown
Для получения текущего значения даты и времени используются функции **`CURRENT_TIMESTAMP`** и **`NOW()`**
*/

SELECT CURRENT_TIMESTAMP

# или

SELECT NOW()

/*markdown
![Alt text](image-3.png)

Список часовых поясов можно увидеть в системном справочнике pg_timezone_names:

![Alt text](image-4.png)
*/

select now() at time zone 'Europe/Moscow'

/*markdown
В таблице ниже приведены примеры того, как работает at time zone для разных типов данных.

![Alt text](image-5.png)
*/

/*markdown
### **DATE**
*/

/* С типом date вы уже знакомы, его реализация предельно проста. Отметим только, 
что тип timestamp (with/without time zone) можно легко перевести в соответствующую дату, 
используя синтаксис: */

"timestamp_column"::date

/* И наоборот, тип date преобразуется в timestamp (дата и 00:00:00) с помощью: */

"date_column"::timestamp

/* Для получения текущей даты можно использовать */

select CURRENT_DATE

/* или */

select now()::date

/*markdown
### **INTERVAL**
*/

/*markdown
![Alt text](image-6.png)

Интервалы хранят данные в трёх отдельных полях — месяцах, днях, секундах. Это сделано из-за того, что количество дней в месяце и часов в дне может быть разным. Пример значения такого типа: `"195 days -10:52:23.563955".`
*/

/*markdown
# ФУНКЦИИ
*/

/*markdown
### ФУНКЦИЯ EXTRACT()
*/

/*markdown
Функция `extract()` получает из значений даты/времени такие поля, как год или час.

Здесь источник — значение типа `timestamp`, `tim`e или `interval`. Допускается и тип `date`, поскольку он приводится к типу `timestamp`.

Указанное поле представляет собой идентификатор, по которому из источника выбирается заданное поле. Функция **`extract()`** возвращает значения типа `double precision`.
*/

/*markdown
**DAY** <br>
Для значений timestamp это день месяца (1-31), для значений interval — число дней.
*/

SELECT EXTRACT(DAY FROM TIMESTAMP '2001-02-16 20:38:40');
/* Результат: 16 */

SELECT EXTRACT(DAY FROM INTERVAL '40 days 1 minute');
/* Результат: 40

/*markdown
**HOUR** <br>
Час (0-23).
*/

SELECT EXTRACT(HOUR FROM TIMESTAMP '2001-02-16 20:38:40');
/* Результат: 20

/*markdown
**MONTH** <br>
Номер месяца, считая с января (1) до декабря (12).
*/

SELECT EXTRACT(MONTH FROM TIMESTAMP '2001-02-16 20:38:40');
/* Результат: 2

/*markdown
**YEAR** <br>
Поле года. Учтите, что года 0 не было, и это следует иметь в виду, вычитая из годов нашей эры годы до нашей эры.
*/

SELECT EXTRACT(YEAR FROM TIMESTAMP '2001-02-16 20:38:40');
/* Результат: 2001

/*markdown
**ISOYEAR** <br>
Год по недельному календарю ISO 8601, в который попадает дата (не применимо к интервалам).
*/

SELECT EXTRACT(ISOYEAR FROM DATE '2006-01-01');
/* Результат: 2005 */

SELECT EXTRACT(ISOYEAR FROM DATE '2006-01-02');
/* Результат: 2006

/*markdown
**WEEK** <br>
Номер недели в году по недельному календарю ISO 8601. По определению, недели ISO 8601 начинаются с понедельника, а первая неделя года включает 4 января этого года. Другими словами, первый четверг года всегда оказывается в первой неделе этого года.

В системе нумерации недель ISO первые числа января могут относиться к 52-й или 53-й неделе предыдущего года, а последние числа декабря — к первой неделе следующего года.

Поэтому для получения согласованных результатов рекомендуется использовать поле isoyear в паре с week.
*/

SELECT EXTRACT(WEEK FROM TIMESTAMP '2001-02-16 20:38:40');
/* Результат: 7

/*markdown
**CENTURY**
*/

SELECT EXTRACT(CENTURY FROM TIMESTAMP '2000-12-16 12:21:13');
/* Результат: 20 */

SELECT EXTRACT(CENTURY FROM TIMESTAMP '2001-02-16 20:38:40');
/* Результат: 21

/*markdown
**DECADE** <br>
Десятилетие.
*/

SELECT EXTRACT(DECADE FROM TIMESTAMP '2001-02-16 20:38:40');
/* Результат: 200

/*markdown
**EPOCH** <br>
Для значений timestamp with time zone это число секунд с 1970-01-01 00:00:00 UTC (может быть отрицательным); для значений date и timestamp это число секунд с 1970-01-01 00:00:00 по местному времени, а для interval — общая длительность интервала в секундах.
*/

SELECT EXTRACT(EPOCH FROM TIMESTAMP WITH TIME ZONE
'2001-02-16 20:38:40.12-08');
/* Результат: 982384720.12

SELECT EXTRACT(EPOCH FROM INTERVAL '5 days 3 hours');
/* Результат: 442800

/*markdown
Преобразовать время эпохи обратно, в значение дата/время, с помощью to_timestamp можно так:
*/

SELECT to_timestamp(982384720.12);
/* Результат: 2001-02-17 04:38:40.12+00

/*markdown
**DOW** <br>
День недели, считая с воскресенья (0) до субботы (6).
*/

SELECT EXTRACT(DOW FROM TIMESTAMP '2001-02-16 20:38:40');
/* Результат: 5

/*markdown
Заметьте, что в extract() дни недели нумеруются не так, как в функции to_char(..., 'D').
*/

/*markdown
**DOY** <br>
День года (1-365/366).
*/

SELECT EXTRACT(DOY FROM TIMESTAMP '2001-02-16 20:38:40');
/* Результат: 47

/*markdown
**ISODOW** <br>
День недели, считая с понедельника (1) до воскресенья (7).
*/

SELECT EXTRACT(ISODOW FROM TIMESTAMP '2001-02-18 20:38:40');
/* Результат: 7

/*markdown
Результат отличается от dow только для воскресенья. Такая нумерация соответствует ISO 8601.
*/

/*markdown
### ФУНКЦИЯ TO_CHAR()
*/

/*markdown
Функция to_char() нужна для форматирования даты времени и интервалов в нужный текст.

Например, вы хотите вывести год, месяц и день со специфическим разделителем или получить текстовое наименование месяца или дня недели. По результату работы она очень близка к extract(), но больше нацелена именно на форматирование. Ниже вы видите таблицу с примерами вызовов:
*/

/*markdown
![alt text](image-7.png)
*/

/*markdown
Первый параметр для функции — дата, время или интервал, а второй — текстовая маска получаемого результата. Перечень значений, которые можно использовать для маски, представлен в таблице ниже.
*/

/*markdown
![alt text](image-8.png)
*/

/*markdown
Полный перечень вы можете посмотреть в подсказке по [кодам форматирования](https://postgrespro.ru/docs/postgrespro/9.5/functions-formatting) или таблице (чтобы увидеть её кликните Показать).
*/

/*markdown
Любой текст, который относится к кодам форматирования, будет сохранён как есть. Чтобы оставлять какие-то подсказки и использовать обычные буквы, которые не встречаются в таблице выше, необходимо заключить текст, который нужно оставить без изменений, в **двойные кавычки**.
*/

/*markdown
Предположим, мы хотим вывести сегодняшнюю дату в формате "Hello! Today is #название дня недели год.название месяца.день#" текстом. Для этого нужно выполнить следующий код: 
*/

select to_char(now(),'"Hello! Today is" DAY yyyy-Mon-dd')

/*markdown
### ФУНКЦИЯ DATE_TRUNC()
*/

/*markdown
Функция **`date_trunc()`** позволяет отсечь заданное время, дату или дату со временем до нужной точности.
*/

/*markdown
Формат вызова:

 **`date_trunc('поле', значение)`**

Например, если мы хотим округлить текущее время-дату до минут, то можно вызвать
*/

 select date_trunc('minute',now())

/*markdown
Для получения разной степени точности вместо minute можно использовать следующие параметры:
![alt text](image-9.png)
Из их названий легко понять, какая временная единица подразумевается.
*/

/*markdown
#  Строковые данные: основные типы
*/

/*markdown
В Postgres есть три основных типа данных для работы со строками: **`character`**, **`character varying`** и **`text`**.

Кратко представим каждый из них.
*/

/*markdown
### CHARACTER
*/

/*markdown
Cтрока фиксированной длины, дополненная пробелами.

Длина строки такого типа всегда одинакова и задаётся в скобках.

`Например, в столбце character(5) всегда будет пять символов: строку большей длины туда вставить не получится, а строка меньшей длины будет дополняться ведущими пробелами. Слово "SQL" в таком столбце будет выглядеть как "  SQL".`

Основной паттерн использования такого типа — универсальные справочники буквенных кодов, например код страны в стандарте ISO (RU, US, UK и т. д.).
*/

/*markdown
### CHARACTER VARYING
*/

/*markdown
Строка ограниченной переменной длины.

`Например, в столбце типа character varying(5) нельзя будет хранить строку большей длины, но могут быть любые строки с меньшей длиной.`

Этот тип данных повсеместно используется для хранения данных, поскольку позволяет ограничить ввод, сохраняя при этом возможность иметь строки произвольной длины.
*/

/*markdown
### TEXT
*/

/*markdown
Cтрока неограниченной длины.

Самый удобный тип для пользователя, но самый тяжеловесный для администратора баз данных, так как в строку можно записать любой текст.

Для удобства все текстовые поля в нашем датасете с доставками представлены типом text.
*/

/*markdown
#  Функции и операторы для работы со строками
*/

/*markdown
## ОПЕРАТОРЫ
*/

/*markdown
#### СОЕДИНЕНИЕ СТРОК
*/

/*markdown
Для начала познакомимся с оператором конкатенации строк — || (две вертикальные черты). Он позволяет объединять две и более строки.

Конструкции с оператором соединения строк записываются следующим образом:

строка1 || строка2 || ... || строкаN
![alt text](image-10.png)
*/

/*markdown
Напишем запрос, который позволит подготовить простые select-запросы для всех таблиц из схемы.
*/

select 'select * from '||t.table_schema||'.'||t.table_name||';' query
from information_schema.tables t
where table_schema = 'shipping'

/*markdown
В результате должно получиться пять SQL-запросов, по одному к каждой таблице из схемы shipping. 

Как мы видим, соединять можно и рукописный текст, и значения столбцов в любом произвольном порядке.
![alt text](image-11.png)
*/

/*markdown
## ФУНКЦИИ
*/

/*markdown
#### UPPER() И LOWER()
*/

/*markdown
Функции upper(your_text) и lower(your_text) переводят каждый символ вашего текста в верхний и нижний регистр соответственно.

Пример:
*/

select upper('Abc') s1 ,lower('xYz') s2

/*markdown
Чаще всего эти функции используются для унификации и стандартизации, особенно они актуальны для данных, введённых вручную.

`Например, названия города в анкете можно написать разными способами, но символьный состав останется одним и тем же (Москва, москва, МОСКВА).`

Результат функций upper() и lower() — тоже строковый, а значит, к нему можно применять все функции, применимые к этому типу данных.
*/

/*markdown
#### REPLACE()
*/

/*markdown
С помощью функции replace() можно заменять символы в строках.
Запись строится следующим образом:

**`replace(string text, from text, to text)`**

Эта запись означает, что в исходной строке string мы заменяем все вхождения строки from на строку to.

Разберём на примере.
*/

select replace('малако','а','о')

/*markdown
Результат выполнения такого запроса будет молоко, т. е. все буквы «а» в строке «малако» были заменены на «о».

С таким же успехом можно заменять строку, состоящую из нескольких символов.

Сделаем из слова «машина» слово «матрас».
*/

select replace('машина','шина','трас')

/*markdown
В строке 'машина' мы заменили строку 'шина' на строку 'трас'.

Результат функции replace() — строка, а значит, к ней тоже можно применять все известные нам функции работы со строками.

Если вы хотите удалить из строки какие-то символы, то третьим параметром (to) передайте пустую строку ''(одинарные кавычки без символа внутри).

Например, сделаем из строки `"Hello, world!"` строку `"Hello!"`.
*/

select replace('Hello, world!',', world','')

/*markdown
#### LEFT() И RIGHT()
*/

/*markdown
Теперь познакомимся с функциями, обрезающими строки.

Функции left(string,n) и right(string,n) оставляют n левых или правых символов от строки, поданной на вход. Давайте разобьём строку 'Один два три' на слова, используя эти функции.
*/

with t as
(
select 'Один два три'::text sample_string
)
select 
 left(t.sample_string,4) one, /*берём 4 левых символа строки*/
 right(left(t.sample_string,8),3) two, /*берём 8 левых символов строки, потом 3 правых от результата*/
 right(t.sample_string,3) three /*берём 3 правых символа от строки*/
from t

/*markdown
Пример:
*/

select left('0123456789', - 2), right('0123456789', - 2)

/*markdown
Результат: 01234567 и 23456789 (в первом случае — восемь символов с «отрезанными» 89 и во втором случае — восемь символов с «отрезанными» 01)
*/

/*markdown
#### FORMAT()
*/

/*markdown
Функция format() используется для составления форматированного текста с подстановками. То же самое можно сделать через конкатенацию строк, но это неудобно и громоздко.

Допустим, у нас есть шаблон "Hello, #Имя пользователя#!" и таблица водителей, которым нужно вывести приветствие.

Через конкатенацию это можно сделать следующим образом:
*/

select 'Hello, ' || d.first_name || '!' hello from shipping.driver d

/*markdown
Но если нужно подставить и имя, и фамилию, то соединений становится слишком много и сам шаблон становится трудночитаемым. Вот тут и приходит на помощь функция format().

Синтаксис функции выглядит следующим образом:

`format(formatstr text [, argument1 text,argument2 text...])`

где `formatstr` — это шаблон, который мы передаём. Это обычная строка, в которой указаны места для подстановки аргумента.

Вернёмся к задаче с приветствием водителя.

Теперь мы можем решить её с помощью **`format()`**:
*/

select format('Hello, %s!', d.first_name) from shipping.driver d

/*markdown
Комбинация символов %s обозначает, что вместо них будет подставлен один из аргументов, причём в том же порядке, что и в исходном столбце.

Напишем запрос, который описывает содержимое каждой строки в таблице в виде текста.
*/

select format('driver_id = %s, first_name = %s, last_name = %s, address = %s, zip_code = %s, phone = %s, city_id = %s', driver_id, first_name, last_name, address, zip_code, phone, city_id) from shipping.driver d

/*markdown
Мы перечислили в строке семь пропусков (плэйсхолдеров, или мест для подстановки, — %s), передали семь параметров (все столбцы таблицы) и получили шаблон, заполненный значениями для каждой строки.

Если в вашем шаблоне присутствует одинарная кавычка, то для удобства можно вместо одинарных кавычек использовать $$ (два знака доллара):
*/

select $$ some_string with quotes ' $$